// Perimortem Engine
// Copyright Â© Matt Kaes

#include "storage/formats/json.hpp"

#include <x86intrin.h>
#include <bit>

using namespace Perimortem::Memory;
using namespace Perimortem::Storage::Json;

auto Node::operator[](uint32_t index) const -> const Node* {
  if (std::holds_alternative<ManagedVector<Node*>>(value)) {
    const auto& vec = get<ManagedVector<Node*>>(value);
    if (vec.get_size() >= index) {
      return nullptr;
    }

    return vec.at(index);
  }

  return nullptr;
}

auto Node::operator[](const std::string_view& name) const -> const Node* {
  if (std::holds_alternative<ManagedLookup<Node>>(value)) {
    return get<ManagedLookup<Node>>(value).at(name);
  }

  return nullptr;
}

auto Node::contains(const std::string_view& name) const -> bool {
  if (std::holds_alternative<ManagedLookup<Node>>(value)) {
    return get<ManagedLookup<Node>>(value).contains(name);
  }

  return false;
}

auto Node::get_bool() const -> const bool* {
  if (std::holds_alternative<bool>(value)) {
    return &get<bool>(value);
  }

  return nullptr;
}

auto Node::get_int() const -> const long* {
  if (std::holds_alternative<long>(value)) {
    return &get<long>(value);
  }

  return nullptr;
}

auto Node::get_double() const -> const double* {
  if (std::holds_alternative<double>(value)) {
    return &get<double>(value);
  }

  return nullptr;
}

auto Node::get_string() const -> const Memory::ByteView* {
  if (std::holds_alternative<ByteView>(value)) {
    return &get<ByteView>(value);
  }

  return nullptr;
}

namespace Perimortem::Storage::Json {
template <uint32_t channels, uint32_t index, uint32_t range>
auto optimized_or_merge(__m256i source[channels]) -> __m256i {
  if constexpr (range == 1) {
    return source[index];
  } else if constexpr (range == 2) {
    return _mm256_or_si256(source[index], source[index + 1]);
  } else {
    return _mm256_or_si256(
        optimized_or_merge<channels, index, (range / 2)>(source),
        optimized_or_merge<channels, index + (range / 2), range - (range / 2)>(
            source));
  }
}

auto vectorized_scan(std::string_view source,
                     const uint32_t position,
                     uint8_t search) -> uint32_t {
  //
  constexpr const auto fused_channels = 4;
  constexpr const auto avx2_channel_width = sizeof(__m256i);
  constexpr const auto full_channel_width = avx2_channel_width * fused_channels;

  auto search_mask = _mm256_set1_epi8(search);
  uint32_t offset = position;
  for (; offset < source.size(); offset += full_channel_width) {
    __m256i masks[fused_channels];
    for (int ymm = 0; ymm < fused_channels; ymm++) {
      const auto value = _mm256_loadu_si256(
          (__m256i*)(source.data() + offset + avx2_channel_width * ymm));
      masks[ymm] = _mm256_cmpeq_epi8(value, search_mask);
    }

    const auto partial_mask_1 = _mm256_or_si256(masks[0], masks[1]);
    const auto partial_mask_2 = _mm256_or_si256(masks[2], masks[3]);
    const auto total_mask = _mm256_or_si256(partial_mask_1, partial_mask_2);
    // Check if we found the byte at all.
    if (!_mm256_testz_si256(total_mask, total_mask)) {
      const uint64_t result_1 = _mm256_movemask_epi8(masks[0]) |
                                (uint64_t)_mm256_movemask_epi8(masks[1]) << 32;
      const uint64_t result_2 = _mm256_movemask_epi8(masks[2]) |
                                (uint64_t)_mm256_movemask_epi8(masks[3]) << 32;

      const auto zeros_1 = std::countr_zero(result_1);
      const auto zeros_2 = std::countr_zero(result_2);
      return offset + zeros_1 + ((zeros_2 + 64) * (zeros_1 == 0));
    }
  }

  // Scalar fallback
  for (; offset < source.size(); offset += 1) {
    if (source[position + offset] == '"') {
      return offset;
    }
  }

  // Not found.
  return -1;
}

auto batch_scan_single(std::string_view source,
                       const uint32_t position,
                       uint8_t search) -> uint32_t {
  // AVX tends to perform worse than scalar operations, so "broadcast" the
  // search value to a simple uint64_t.
  uint64_t search_mask = static_cast<uint64_t>(search) * 0x0101010101010101ULL;
  uint32_t offset = position;

  // Read 16 byte chunks at a time.
  for (; offset < source.size() - sizeof(uint64_t);
       offset += sizeof(uint64_t)) {
    uint64_t buffer_1 = *(const uint64_t*)(source.data() + offset);

    // Perform a bit level check. If the bytes are equal we need 0xFF in that
    // slot.
    buffer_1 = ~(buffer_1 ^ search_mask);

    // Reduce the results making sure the LSB of each byte is compared with
    // every other bit in the byte.
    buffer_1 &= buffer_1 >> 4;
    buffer_1 &= buffer_1 >> 2;
    buffer_1 &= buffer_1 >> 1;

    // If there are any zeros (mismatched bytes) the LSB will be zero.
    // The other bits will have garbage data so wipe them.
    buffer_1 &= 0x0101010101010101;

    // Check if we found have at least one match.
    if (buffer_1) {
      // Get the position by where the bit is
      const auto zeros_1 = std::countr_zero(buffer_1) / 8;
      return offset + zeros_1;
    }
  }

  // Scalar fallback
  for (; offset < source.size(); offset += 1) {
    if (source[offset] == '"') {
      return offset;
    }
  }

  // Not found.
  return -1;
}

auto batch_scan(std::string_view source,
                const uint32_t position,
                uint8_t search) -> uint32_t {
  // AVX tends to perform worse than scalar operations, so "broadcast" the
  // search value to a simple uint64_t.
  uint64_t search_mask = static_cast<uint64_t>(search) * 0x0101010101010101ULL;
  uint32_t offset = position;

  // Read 16 byte chunks at a time.
  for (; offset < source.size() - sizeof(uint64_t) * 2;
       offset += sizeof(uint64_t) * 2) {
    uint64_t buffer_1 = *(const uint64_t*)(source.data() + offset);
    uint64_t buffer_2 =
        *(const uint64_t*)(source.data() + offset + sizeof(uint64_t));

    // Perform a bit level check. If the bytes are equal we need 0xFF in that
    // slot.
    buffer_1 = ~(buffer_1 ^ search_mask);
    buffer_2 = ~(buffer_2 ^ search_mask);

    // Reduce the results making sure the LSB of each byte is compared with
    // every other bit in the byte.
    buffer_1 &= buffer_1 >> 4;
    buffer_2 &= buffer_2 >> 4;
    buffer_1 &= buffer_1 >> 2;
    buffer_2 &= buffer_2 >> 2;
    buffer_1 &= buffer_1 >> 1;
    buffer_2 &= buffer_2 >> 1;

    // If there are any zeros (mismatched bytes) the LSB will be zero.
    // The other bits will have garbage data so wipe them.
    buffer_1 &= 0x0101010101010101;
    buffer_2 &= 0x0101010101010101;

    // Check if we found have at least one match.
    if (buffer_1 | buffer_2) {
      // Get the position by where the bit is
      const auto zeros_1 = std::countr_zero(buffer_1) / 8;
      const auto zeros_2 = std::countr_zero(buffer_2) / 8;
      return offset + zeros_1 + (zeros_2 * (buffer_1 == 0));
    }
  }

  // Scalar fallback
  for (; offset < source.size(); offset += 1) {
    if (source[offset] == '"') {
      return offset;
    }
  }

  // Not found.
  return -1;
}

// Scans ahead 32 bytes to search for value.
auto fast_scan(std::string_view source, const uint32_t position, uint8_t search)
    -> uint32_t {
  auto search_mask = _mm256_set1_epi8(search);
  const auto value = _mm256_loadu_si256((__m256i*)(source.data() + position));
  const auto compare = _mm256_cmpeq_epi8(value, search_mask);
  const uint32_t offset_mask = _mm256_movemask_epi8(compare);
  return position + std::countr_zero(offset_mask);
}

auto parse_string(std::string_view source, uint32_t& position)
    -> ByteView {
  uint32_t start = ++position;
  position = vectorized_scan(source, position, '"');

  // position = batch_scan(source, position, '"');
  // position = batch_scan_single(source, position, '"');

  // // Optimize for vectorizing as large source files come over as base 64.
  // while (true) {
  //   constexpr const uint32_t look_ahead = 16;
  //   for (uint32_t i = 0; i < look_ahead; i++) {
  //     if (source[position + i] == '"') {
  //       position += i;
  //       goto finished;
  //     }
  //   }

  //   position += look_ahead;
  // }
// finished:
  return ByteView(source.substr(start, position++ - start));
}

auto ignored_characters(char c) {
  return c == ',';
}

auto parse(Memory::Arena& arena, std::string_view source, uint32_t& position)
    -> Node* {
  if (position > source.size()) {
    return nullptr;
  }

  // Allocations are cheap and we throw away the entire stack if the parse is
  // bad so it profiled slightly faster to just pull out the construct to the
  // top level.
  Node* node = arena.construct<Node>();

  while (position < source.size()) {
    const auto start_char = source[position];
    switch (start_char) {
      // Object
      case '{': {
        ManagedLookup<Node> members(arena);
        position++;

        while (position < source.size() && source[position] != '}') {
          if (source[position] != '"') {
            position++;
            continue;
          }
          // position = fast_scan(source, position, '"');

          // const auto start = ++position;
          // position = fast_scan(source, position, '"');
          // auto name = ByteView(source.substr(start, position++ -
          // start));

          // // Encountered an extra long name so try a full parse.
          // if (name.get_size() == 32) {
          //   position -= 33;
          //   name = parse_string(source, position);
          //   if (name.empty()) {
          //     return nullptr;
          //   }
          // }

          auto name = parse_string(source, position);
          if (name.empty()) {
            return nullptr;
          }

          // :
          position++;

          auto child = parse(arena, source, position);
          if (!child) {
            return nullptr;
          }

          members.insert(name, child);
        }

        // If we are past the end then this is safe as we null out anyway.
        // If we are at a valid closing '}' then this consumes it.
        position++;
        node->set(members);
        return node;
      }

      // Array
      case '[': {
        ManagedVector<Node*> items(arena);
        position++;

        while (position < source.size() && source[position] != ']') {
          if (ignored_characters(source[position])) {
            position++;
          }

          auto child = parse(arena, source, position);
          if (!child) {
            return nullptr;
          }

          items.insert(child);
          node->set(items);
        }

        // If we are past the end then this is safe as we null out anyway.
        // If we are at a valid closing ']' then this consumes it.
        position++;
        return node;
      }

      // String
      case '"': {
        auto name = parse_string(source, position);

        node->set(name);
        return node;
      }

      // true
      case 't': {
        if (position + 3 >= source.size() ||
            std::memcmp(source.data() + position, "true", 4)) {
          return nullptr;
        }

        // Move past "true"
        position += 4;

        node->set(true);
        return node;
      }

      // false
      case 'f': {
        if (position + 4 >= source.size() ||
            std::memcmp(source.data() + position, "false", 5)) {
          return nullptr;
        }

        // Move past "false"
        position += 5;

        node->set(false);
        return node;
      }

      // Numbers
      case '-':
      case '0' ... '9': {
        bool negative = false;
        if (source[position] == '-') {
          negative = true;
          position++;
        }

        long value = 0;
        while (position < source.size() && source[position] >= '0' &&
               source[position] <= '9') {
          value *= 10;
          value += source[position] - '0';
          position++;
        }

        if (position < source.size() && source[position] != '.') {
          node->set(value * (negative ? -1 : 1));
          return node;
        }

        double float_value = value;
        double divisor = 1.0;
        while (position < source.size() && source[position] >= '0' &&
               source[position] <= '9') {
          float_value *= 10;
          divisor *= 10;
          float_value += source[position] - '0';
          position++;
        }

        if (position < source.size()) {
          node->set((float_value / divisor) * (negative ? -1 : 1));
          return node;
        }

        return nullptr;
      }

      case ',':
        position++;
        break;

      default:
        return nullptr;
    }
  }
  return nullptr;
}

}  // namespace Perimortem::Storage::Json
