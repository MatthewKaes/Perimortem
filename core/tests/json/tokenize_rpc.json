{"jsonrpc":"2.0","id":1,"method":"tokenize","params":{"source":"//\n// A basic class for testing parsing asdf\n//\n// along with a bunch of other gunk\n//\npackage library;\n/> @UseCppTheme\n// Importing the top type from another file. Top types are always constant\n// references and can not be new-ed even though they live on the heap. (they are\n// singletons).\n\nusing library Data as \"Data.ttx\";\nusing entity Empty as \"Empty.txx\";\n\n// Constant object - Must be a Stack type and foldable. Generally all keywords\n// and types are this. You generally should have your types be constant.\n[=/=] magic_number : Int = 10;\n\n// Dynamic object - May be any type, exported and serialized.\n[=>>] global_value : Int = 24;\n\n// Hidden object - May be any type, not exported but is serialized.\n[=!=] static_value : Int = 92;\n\n// Temporary object - May be any type, not exported and not serialized. Can be\n// used as private variables or working objects.\n[***] temp_value : Int = 92;\n\n// All types are constructable, but are either a Stack or Heap type. Stack types\n// use `init` while Heap types use `new`.\n[***] temp_default : Int = Int -> new();\n\n// returns 0 Type aliases are easy enough to make. Just make sure they are const.\n[=/=] Vec2D : alias = Vec[Num, 2];\n\n// You can also reexport if neccessary. Since it's const it will get dedupped\n// during compliation.\n[=/=] MyType : alias = Empty.TestType;\n\n// `init class` -> Creates a new Stack Type Stack types are copied by value but\n// they aren't dynamically allocated. Stack types can only include other stack\n// types. Stack types assign by memcpy which makes them super speedy\n[=/=] Size : struct {\n  [=>>] width : Int = 0;\n  [=>>] height : Int = 0;\n\n  // This won't work as it requires a Heap type. [=>>] info:Text = Text -> new();\n  // Temporary functions act more or less as static functions as the function\n  // exists on the type.\n  [=>>] create : func(width : Int, height : Int) return -> Size = {\n    // In constant functions the this refers\n    debug();\n\n    // Prints \"Size:class\"\n    self.width = width;\n    self.height = height;\n  }\n\n  [=>>] create : func(width : Int, height : Int) return -> Size {\n    // In constant functions the this refers\n    debug();\n\n    // Prints \"Size:class\"\n    self.width = width;\n    self.height = height;\n  }\n}\n\n// `new class` -> Creates a new Heap Type Heap types are always passed by \"valid\n// pointers\" You can not have a null heap type. Stack types assign by memcpy which\n// makes them super speedy\n[=>>] Rect : object {\n  // Constant object - Must be a Stack type and foldable. Const values do not add\n  // storage to the object.\n  [=/=] const_value : Int = 10;\n\n  // Dynamic object - Accessable outside of type, serialized. Typical Godot like\n  // variable.\n  [=>>] public_variable : Int = 24;\n\n  // Hidden object - Not accessable outside of type, serialized. Private variable\n  // typically for cleaning up API.\n  [=!=] private_variable : Int = 92;\n\n  // Hidden object - Not accessable outside of type, not serialized. Variables\n  [***] temp_value : Int = 92;\n\n  // Tetrodotoxin avoids constructors and the ordering from them. Instead all\n  // variables and functions are initalized to a base state when allocated. (Order\n  // is not gurenteed)\n  [***] size : Size = Size -> new();\n  [=!=] colors : Dict[Str, Str] = Dict[Str, Str] -> new();\n  [=!=] constant : Dict[Str, Str] = Dict[Str, Str] -> new();\n\n  // [=/=] All functions are stored in variables. Blocks are generated as lambdas\n  // which are linked at the LLVM level. Constant functions are powerful as their\n  // \"address\" is constant enabling a number of optimizations. Constant functions\n  // add no size to instantiations of the type.\n  [=/=] area : func =() -> Int {\n    return self.size.x * self.size.y;\n  }\n\n  // [=>>] Just like regular dynamic attributes these functions can be changed at\n  // runtime, as long as it always points to a valid location. Even if you plan to\n  // always change the function, you must point it to a valid function to start.\n  [=>>] grow : func =(size : Size) -> Rect = {\n    self.size.width += size.width;\n    self.size.height += size.height;\n\n    // Return this object on the stack.\n    return self;\n  }\n\n  // [=!=] Hidden functions can be used as private objects. You can also fully\n  // qualify the func, but it's unneccessary Note that all functions must have a\n  // return type.\n  //\n  // If you fully quality the function call, it's\n  [=!=] grow : func[Rect, Size, Rect] =(self : Rect, size : Size) -> Rect {\n    self.size.width += size.width;\n    self.size.height += size.height;\n\n    // Return this object on the stack.\n    return self;\n  }\n\n  // Temporary functions act more or less as static functions as the function\n  // exists on the types.\n  [***] create_size : func =(self : class) -> Size {\n    // In constant functions the this refers\n    debug(self);\n\n    // Prints \"Size:class\"\n    self.width = width;\n    self.height = height;\n  }\n}\n\n// The types technically live in the singleton object, so a fully qualified type\n// line would be the following:\n[=/=] grow_rect : func =(src : Rectangle.Rect, size : Rectangle.Size) = Rectangle.Rect {\n  // Types can be used, but since this is attached to a singleton it's fine to\n  // just use it how you want.\n  self -> log(self.magic_number);\n  [=>>] res : Rect = src;\n  return res -> grow(size);\n}\n\n[=>>] log : func(src : Any) -> Rect {\n  // Functions can technically export variables, but generally you'll want it to\n  // live on an easier to track singleton than the lambda.\n  [=>>] tag : Vec[Byt, 10] = \"[Log] \";\n  debug(tag + src);\n}\n\n// Temporary functions are special and can only be called from a local `on_load`\n// function. They are only invocable by the TTX loader.\n[***] on_load : func() -> Byt {\n  [***] rect : Rect = Rect -> new();\n  [***] i : Int = 0;\n  for (i = 0;  i < 5;  i += 1) {\n    debug(\"Value is \" + i);\n  }\n\n  Rectangle.log.tag = \"[New] \";\n  Rectangle -> grow_rect(rect, new Size(10, 10));\n  Rectangle -> log(rect -> area());\n  debug(\"Area of Rect is: \" + rect -> area());\n  return 0;\n}\n"}}